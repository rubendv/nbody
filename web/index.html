<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>N-Body</title>
</head>
<body>
    <canvas id="mainView"></canvas>
    <script>
        "use strict";

        var bodies = [[], [], [], [], [], []];

        function setMessageHandler(onmessage) {
            var ws = new WebSocket("wss://rubendv.be/nbody-ws", []);
            ws.binaryType = 'arraybuffer';
            ws.onopen = function(event) {
                console.log("Websocket connected");
            };
            ws.onerror = function(event) {
                console.log("Websocket error: " + JSON.stringify(event));
            };
            ws.onmessage = function(event) {
                onmessage(ws, event.data);
            };
            ws.onclose = function(event) {
                console.log("Websocket disconnected");
                setTimeout(function() { setMessageHandler(onmessage); }, 1000);
            };
        }



        (function(bodies) {
            let canvas = document.getElementById("mainView");
            let ctx = canvas.getContext("2d");

            window.addEventListener("resize", resizeCanvas, false);

            function scale_coord_x(x) {
                return window.innerWidth / 2 * x / 8 + window.innerWidth / 2;
            }

            function scale_coord_y(y) {
                return window.innerHeight / 2 * y / 8 + window.innerHeight / 2;
            }


            function rainbow(numOfSteps, step) {
                // This function generates vibrant, "evenly spaced" colours (i.e. no clustering). This is ideal for creating easily distinguishable vibrant markers in Google Maps and other apps.
                // Adam Cole, 2011-Sept-14
                // HSV to RBG adapted from: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
                var r, g, b;
                var h = step / numOfSteps;
                var i = ~~(h * 6);
                var f = h * 6 - i;
                var q = 1 - f;
                switch(i % 6){
                    case 0: r = 1; g = f; b = 0; break;
                    case 1: r = q; g = 1; b = 0; break;
                    case 2: r = 0; g = 1; b = f; break;
                    case 3: r = 0; g = q; b = 1; break;
                    case 4: r = f; g = 0; b = 1; break;
                    case 5: r = 1; g = 0; b = q; break;
                }
                var c = "#" + ("00" + (~ ~(r * 255)).toString(16)).slice(-2) + ("00" + (~ ~(g * 255)).toString(16)).slice(-2) + ("00" + (~ ~(b * 255)).toString(16)).slice(-2);
                return (c);
            }

            let X = 0;
            let Y = 1;
            let DXDT = 2;
            let DYDT = 3;
            let M = 4;
            let ID = 5;

            let clear = true;

            function draw() {
                if(clear) {
                    ctx.fillStyle = "black";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    clear = false;
                }

                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for(let i = 0; i < bodies[ID].length; i++) {
                    let x = scale_coord_x(bodies[X][i]);
                    let y = scale_coord_y(bodies[Y][i]);
                    ctx.fillStyle = rainbow(bodies.length, bodies[ID][i]);
                    let size = Math.pow(bodies[M][i], 1 / 3) * 2;
                    ctx.beginPath();
                    // TODO: make sure centering is correct
                    ctx.arc(x, y, size, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                draw();
            }

            resizeCanvas();

            setMessageHandler(function(ws, message) {
                let N = message.byteLength / Float64Array.BYTES_PER_ELEMENT / 6;
                bodies[X] = new Float64Array(message, Float64Array.BYTES_PER_ELEMENT*N*X, N);
                bodies[Y] = new Float64Array(message, Float64Array.BYTES_PER_ELEMENT*N*Y, N);
                bodies[DXDT] = new Float64Array(message, Float64Array.BYTES_PER_ELEMENT*N*DXDT, N);
                bodies[DYDT] = new Float64Array(message, Float64Array.BYTES_PER_ELEMENT*N*DYDT, N);
                bodies[M] = new Float64Array(message, Float64Array.BYTES_PER_ELEMENT*N*M, N);
                bodies[ID] = new Float64Array(message, Float64Array.BYTES_PER_ELEMENT*N*ID, N);
                //console.log('Received tick for time ' + parsed.time);
                draw();
            });
        })(bodies);





    </script>
</body>
</html>
