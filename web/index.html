<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>N-Body</title>
</head>
<body>
    <canvas id="mainView"></canvas>
    <script>
        "use strict";

        var bodies = [];

        function setMessageHandler(onmessage) {
            var ws = new WebSocket("ws://localhost:9000", []);
            ws.onopen = function(event) {
                console.log("Websocket connected");
            };
            ws.onerror = function(event) {
                console.log("Websocket error: " + JSON.stringify(event));
            };
            ws.onmessage = function(event) {
                onmessage(ws, event.data);
            };
            ws.onclose = function(event) {
                console.log("Websocket disconnected");
            };
        }



        (function(bodies) {
            let canvas = document.getElementById("mainView");
            let ctx = canvas.getContext("2d");

            window.addEventListener("resize", resizeCanvas, false);

            function scale_coord(coord) {
                return {
                    x: window.innerWidth/2 * coord.x/4 + window.innerWidth/2,
                    y: window.innerHeight/2 * coord.y/2 + window.innerHeight/2
                };
            }

            function rainbow(numOfSteps, step) {
                // This function generates vibrant, "evenly spaced" colours (i.e. no clustering). This is ideal for creating easily distinguishable vibrant markers in Google Maps and other apps.
                // Adam Cole, 2011-Sept-14
                // HSV to RBG adapted from: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
                var r, g, b;
                var h = step / numOfSteps;
                var i = ~~(h * 6);
                var f = h * 6 - i;
                var q = 1 - f;
                switch(i % 6){
                    case 0: r = 1; g = f; b = 0; break;
                    case 1: r = q; g = 1; b = 0; break;
                    case 2: r = 0; g = 1; b = f; break;
                    case 3: r = 0; g = q; b = 1; break;
                    case 4: r = f; g = 0; b = 1; break;
                    case 5: r = 1; g = 0; b = q; break;
                }
                var c = "#" + ("00" + (~ ~(r * 255)).toString(16)).slice(-2) + ("00" + (~ ~(g * 255)).toString(16)).slice(-2) + ("00" + (~ ~(b * 255)).toString(16)).slice(-2);
                return (c);
            }

            function draw() {
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height);


                for(let i = 0; i < bodies.length; i++) {
                    let body = bodies[i];
                    let coord = scale_coord(body);
                    ctx.fillStyle = rainbow(bodies.length, i);
                    let size = Math.pow(body.mass, 1 / 3) * 20;
                    ctx.beginPath();
                    // TODO: make sure centering is correct
                    ctx.arc(coord.x, coord.y, size, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                draw();
            }

            resizeCanvas();

            setMessageHandler(function(ws, message) {
                let parsed = JSON.parse(message);
                bodies = parsed.bodies;
                console.log('Received tick for time ' + parsed.time);
                draw();
            });
        })(bodies);





    </script>
</body>
</html>