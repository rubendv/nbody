<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>N-Body</title>
</head>
<body>
    <canvas id="mainView"></canvas>
    <script>
        "use strict";

        var bodies = [[], [], [], [], [], []];

        function setMessageHandler(onmessage) {
            var ws = new WebSocket("ws://localhost:9000", []);
            ws.onopen = function(event) {
                console.log("Websocket connected");
            };
            ws.onerror = function(event) {
                console.log("Websocket error: " + JSON.stringify(event));
            };
            ws.onmessage = function(event) {
                onmessage(ws, event.data);
            };
            ws.onclose = function(event) {
                console.log("Websocket disconnected");
            };
        }



        (function(bodies) {
            let canvas = document.getElementById("mainView");
            let ctx = canvas.getContext("2d");

            window.addEventListener("resize", resizeCanvas, false);

            function scale_coord_x(x) {
                return window.innerWidth / 2 * x / 8 + window.innerWidth / 2;
            }

            function scale_coord_y(y) {
                return window.innerHeight / 2 * y / 8 + window.innerHeight / 2;
            }


            function rainbow(numOfSteps, step) {
                // This function generates vibrant, "evenly spaced" colours (i.e. no clustering). This is ideal for creating easily distinguishable vibrant markers in Google Maps and other apps.
                // Adam Cole, 2011-Sept-14
                // HSV to RBG adapted from: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
                var r, g, b;
                var h = step / numOfSteps;
                var i = ~~(h * 6);
                var f = h * 6 - i;
                var q = 1 - f;
                switch(i % 6){
                    case 0: r = 1; g = f; b = 0; break;
                    case 1: r = q; g = 1; b = 0; break;
                    case 2: r = 0; g = 1; b = f; break;
                    case 3: r = 0; g = q; b = 1; break;
                    case 4: r = f; g = 0; b = 1; break;
                    case 5: r = 1; g = 0; b = q; break;
                }
                var c = "#" + ("00" + (~ ~(r * 255)).toString(16)).slice(-2) + ("00" + (~ ~(g * 255)).toString(16)).slice(-2) + ("00" + (~ ~(b * 255)).toString(16)).slice(-2);
                return (c);
            }

            function draw() {
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                let X = 0;
                let Y = 1;
                let DXDT = 2;
                let DYDT = 3;
                let M = 4;
                let ID = 5;

                for(let i = 0; i < bodies[ID].length; i++) {
                    let x = scale_coord_x(bodies[X][i]);
                    let y = scale_coord_y(bodies[Y][i]);
                    ctx.fillStyle = rainbow(bodies.length, bodies[ID][i]);
                    let size = Math.pow(bodies[M][i], 1 / 3) * 2;
                    ctx.beginPath();
                    // TODO: make sure centering is correct
                    ctx.arc(x, y, size, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                draw();
            }

            resizeCanvas();

            setMessageHandler(function(ws, message) {
                let parsed = JSON.parse(message);
                bodies = parsed.bodies;
                //console.log('Received tick for time ' + parsed.time);
                draw();
            });
        })(bodies);





    </script>
</body>
</html>